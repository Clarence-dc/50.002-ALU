module rand_gen (
    input clk,  // clock
    input rst,  // reset
    input num[4], // number or empty registers
    output randint[5]
  ) {
  
  alu alu;
  .clk(clk){
  
  counter randseed(.rst(rst), #SIZE(32));
  .rst(rst){
  fsm game_step = {
    START,
    RAND,
    DONE 
     };
     
   fsm rand_step = {
    BITMASK,
    MULTIPLY,
    EXTRACT
    };
   dff randint1[5](#INIT(0));
   dff randint_temp[16];
   pn_gen rand_gen;   
    }
  }
  
  always {
    rand_gen.next = 1;
    rand_gen.seed = randseed.value;
    alu.alufn = 6b000000;
    alu.a = 16b0;
    alu.b = 16b0;
    randint = 0;
    
    
    case(game_step.q){
      game_step.START:
        randint1.d = 0;
        rand_gen.next = 1;
        alu.a = 0;
        alu.b = 0;
        alu.alufn = 0;   
        game_step.d = game_step.RAND;
        
      game_step.RAND:
         case(rand_step.q){
         rand_step.BITMASK: // Bitmask out upper 4 bits of PRNG.
            rand_gen.next = 1;
            alu.a = rand_gen.num[15:0];
            alu.b = 16b0000111111111111;
            alu.alufn = Alufn.AND;
            randint_temp.d = alu.out[15:0];
            rand_step.d = rand_step.MULTIPLY;
            
          rand_step.MULTIPLY: // Multiply by number of empty_slots.
            alu.a = randint_temp.q;
            alu.b = num;
            alu.alufn = Alufn.MUL;
            randint_temp.d = alu.out[15:0];
            rand_step.d = rand_step.EXTRACT;
            
          rand_step.EXTRACT: // Extract randint by shifting.  
            alu.a = randint_temp.q;
            alu.b = 16d12;  
            alu.alufn = Alufn.SHR;    
            randint1.d = alu.out[3:0];
            game_step.d = game_step.DONE;       
        }
      game_step.DONE:
            randint = randint1.q+b10000;
            if(rst){
            game_step.d = game_step.START;
            }
  }
}
}