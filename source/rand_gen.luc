global Alufn{
  const ADD   = 6b000000;
  const SUB   = 6b000001;
  const MUL   = 6b000010;
  const AND   = 6b011000;
  const OR    = 6b011110;
  const XOR   = 6b010110;
  const A     = 6b011010;
  const SHL   = 6b100000;
  const SHR   = 6b100001;
  const SRA   = 6b100011;
  const CMPEQ = 6b110011;
  const CMPLT = 6b110101;
  const CMPLE = 6b110111;
}

module rand_gen (
    input clk,  // clock
    input rst,  // reset
    input reg_array[9], // array of empty registers
    output rand1[5],
    output rand2[5]
  ) {
  
  alu alu;
  .clk(clk){
  
  counter randseed(.rst(rst), #SIZE(32));
  .rst(rst){
  dff empty_slots[4](#INIT(9));
  fsm game_step = {
    START,
    RAND1,
    RAND2,
    DONE 
     };
     
   fsm rand_step = {
    BITMASK,
    MULTIPLY,
    EXTRACT
    };
   dff randint1[3];
   dff randint2[4];
   dff randint_temp[16];
   dff index_count[4];
   pn_gen rand_gen;   
    }
  }
  
  always {
    rand_gen.next = 1;
    rand_gen.seed = randseed.value;
    alu.alufn = 6b000000;
    alu.a = 16b0;
    alu.b = 16b0;
    rand1 = 0;
    rand2 = 0;
    
    
    case(game_step.q){
      game_step.START:
        randint1.d = 0;
        randint2.d = 0;
        rand_gen.next = 1;
        alu.a = 0;
        alu.b = 0;
        alu.alufn = 0;
        index_count.d = index_count.q + 1;
        empty_slots.d = empty_slots.q-reg_array[index_count.q];     
        if (index_count.q >=8){
        game_step.d = game_step.RAND1;
        }
      
      game_step.RAND1:
        rand_gen.next = 1;
        alu.a = rand_gen.num[15:0];
        alu.b = 16b111;
        alu.alufn = Alufn.AND;
        randint1.d = alu.out[2:0];
        game_step.d = game_step.RAND2;
        rand_step.d = rand_step.BITMASK;
        
      game_step.RAND2:
         case(rand_step.q){
         rand_step.BITMASK: // Bitmask out upper 4 bits of PRNG.
            rand_gen.next = 1;
            alu.a = rand_gen.num[15:0];
            alu.b = 16b0000111111111111;
            alu.alufn = Alufn.AND;
            randint_temp.d = alu.out[15:0];
            rand_step.d = rand_step.MULTIPLY;
            
          rand_step.MULTIPLY: // Multiply by number of empty_slots.
            alu.a = randint_temp.q;
            alu.b = empty_slots.q;
            alu.alufn = Alufn.MUL;
            randint_temp.d = alu.out[15:0];
            rand_step.d = rand_step.EXTRACT;
            
          rand_step.EXTRACT: // Extract randint by shifting.          
            randint2.d = randint_temp.q[15:12];
            game_step.d = game_step.DONE;       
        }
      game_step.DONE:
      rand1 = randint1.q+b10000;
      rand2 = randint2.q+b10000;
            if(rst){
            game_step.d = game_step.START;
            index_count.d = 0;
            empty_slots.d = 9;
            }
  }
}
}