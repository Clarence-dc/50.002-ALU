/*
   This file was generated automatically by Alchitry Labs version 1.2.1.
   Do not edit this file directly. Instead edit the original Lucid source.
   This is a temporary file and any changes made to it will be destroyed.
*/

module alu_9 (
    input [15:0] a,
    input [15:0] b,
    input [5:0] alufn,
    output reg [15:0] out,
    output reg [2:0] zvn,
    output reg [19:0] seg
  );
  
  
  
  wire [16-1:0] M_adder_s;
  wire [1-1:0] M_adder_z;
  wire [1-1:0] M_adder_v;
  wire [1-1:0] M_adder_n;
  reg [16-1:0] M_adder_a;
  reg [16-1:0] M_adder_b;
  reg [6-1:0] M_adder_alufn;
  add_sub16bit_15 adder (
    .a(M_adder_a),
    .b(M_adder_b),
    .alufn(M_adder_alufn),
    .s(M_adder_s),
    .z(M_adder_z),
    .v(M_adder_v),
    .n(M_adder_n)
  );
  
  wire [16-1:0] M_bool_boole;
  reg [16-1:0] M_bool_a;
  reg [16-1:0] M_bool_b;
  reg [6-1:0] M_bool_alufn;
  boolean_16 bool (
    .a(M_bool_a),
    .b(M_bool_b),
    .alufn(M_bool_alufn),
    .boole(M_bool_boole)
  );
  
  wire [16-1:0] M_shift_out;
  reg [16-1:0] M_shift_a;
  reg [16-1:0] M_shift_b;
  reg [6-1:0] M_shift_alufn;
  shifter_17 shift (
    .a(M_shift_a),
    .b(M_shift_b),
    .alufn(M_shift_alufn),
    .out(M_shift_out)
  );
  
  wire [1-1:0] M_comp_cmp;
  reg [1-1:0] M_comp_z;
  reg [1-1:0] M_comp_v;
  reg [1-1:0] M_comp_n;
  reg [6-1:0] M_comp_alufn;
  comparator_18 comp (
    .z(M_comp_z),
    .v(M_comp_v),
    .n(M_comp_n),
    .alufn(M_comp_alufn),
    .cmp(M_comp_cmp)
  );
  
  always @* begin
    M_adder_a = a;
    M_adder_b = b;
    M_bool_a = a;
    M_bool_b = b;
    M_shift_a = a;
    M_shift_b = b;
    M_comp_z = M_adder_z;
    M_comp_v = M_adder_v;
    M_comp_n = M_adder_n;
    M_adder_alufn = alufn;
    M_bool_alufn = alufn;
    M_shift_alufn = alufn;
    M_comp_alufn = alufn;
    out = 1'h0;
    zvn[0+0-:1] = M_adder_z;
    zvn[1+0-:1] = M_adder_v;
    zvn[2+0-:1] = M_adder_n;
    seg = 20'h84210;
    
    case (alufn[4+1-:2])
      2'h0: begin
        
        case (alufn[0+1-:2])
          2'h0: begin
            seg = 20'h14060;
          end
          2'h1: begin
            seg = 20'h14064;
          end
          2'h2: begin
            if (M_adder_s / b == a) begin
              seg = 20'h14065;
            end else begin
              seg = 20'h294a5;
            end
          end
          2'h3: begin
            seg = 20'h14066;
          end
        endcase
        out = M_adder_s;
      end
      2'h1: begin
        seg = 20'h140f0;
        
        case (alufn[0+3-:4])
          4'h8: begin
            seg = 20'h140e8;
          end
          4'he: begin
            seg = 20'h140e2;
          end
          4'h6: begin
            seg = 20'h140e5;
          end
          4'ha: begin
            seg = 20'h140e9;
          end
        endcase
        out = M_bool_boole;
      end
      2'h2: begin
        seg = 20'h14150;
        
        case (alufn[0+1-:2])
          2'h0: begin
            seg = 20'h14149;
          end
          2'h1: begin
            seg = 20'h1414b;
          end
          2'h3: begin
            seg = 20'h1414c;
          end
        endcase
        out = M_shift_out;
      end
      2'h3: begin
        seg = 20'h141b0;
        
        case (alufn[0+3-:4])
          4'h5: begin
            seg = 20'h141ae;
          end
          4'h9: begin
            seg = 20'h141a9;
          end
          4'hd: begin
            seg = 20'h141af;
          end
        endcase
        out[1+14-:15] = 1'h0;
        out[0+0-:1] = M_comp_cmp;
      end
    endcase
  end
endmodule
